# Technical debt

## Index

- [Direct Pokemon entity modification on favorite mutation](https://github.com/ddialar/pokemon.challenge/blob/master/TECH-DEBT.md#direct-entity-modification)
- [Strong coupling with the persistance model definition](https://github.com/ddialar/pokemon.challenge/blob/master/TECH-DEBT.md#persistance-model-coupling)
- [Improve the reported errors to the client application](https://github.com/ddialar/pokemon.challenge/blob/master/TECH-DEBT.md#errors-enhancement)
- [Improve the API security configuring sensitive headers](https://github.com/ddialar/pokemon.challenge/blob/master/TECH-DEBT.md#implement-helmet)
- [Improve the API security implementing some kind of rate limiter](https://github.com/ddialar/pokemon.challenge/blob/master/TECH-DEBT.md#implement-rate-limiter)

## <a id="description"></a>

## <a id="direct-entity-modification"></a> ➡️ Direct Pokemon entity modification on favorite mutation

### Problem

In order to set any Pokemon as favorite, the original document is edited adding a new `favorite` field or updating its value.

### Why it was done this way?

In the proyect requirement there was not defined any use case indicating an opposite option.

### Why this way is problematic?

The original data structure must not be edited except if it's going to update the specific data structure.

Whether a Pokemon is favorite or not is information directly bound with a specific user and not with the Pokemon.

Besides that, in case the application provides the posibility to handle multiple users, in the current situation we won't be able to differentiate between which user's Pokemons are favorite.

### What the solution might be?

To create an intermeditate collection in order to store the user's ID as well as an array of favorite Pokemons' IDs.

This action would provide an independent list about relationships between users and favorite Pokemons.

### Why we aren't already doing the above?

To implement this process requires to be able to handle multiple users as well as authentication and identifying processes whose are not defined in the challenge requirements.

In the absence of being able to confirm these requirements, to proceed with its implementation would be an over engineering process.

### Next steps

- Report to the project owner this situation.
- Confirm the project needs.
- Proceed with the required features.

### Other notes

There are no additional notes.

## <a id="persistance-model-coupling"></a> ➡️ Strong coupling with the persistance model definition

### Problem

In order access the persisted data, the services are using the information and data structure provided by the repositories.

### Why it was done this way?

Due to there is not any specific treatment of retrieved data and they are served to the client application in the same way they have been defined in the database, it was not needed to implement additional and useless code between the answer provided by the repository and the service business logic.

### Why this way is problematic?

If in future versions of the application, the database structure changes, besides to refactor the data model, the client application should refactored as well in order to adapt it to the new responses.

This way we are getting a huge strong coupling between client and backend.

### What the solution might be?

To create a domain model structure as well as the needed adapters structure in order to decoupling the handle information by the domain and the persistance layers.

Once it's done, we can provide the client application with a better structured data, with a inproved isolation and protection agains future data structure modifications.

### Why we aren't already doing the above?

Due to the required information by the possible cliente application uses the same field names that defined in the persistance layer, in the current situation, to implement the needed isolation layers is an over engineering process without additional confirmed requirements.

### Next steps

- To continue tracking the application development.
- To keep in mind this situation and be ready to implement the needed layers.

### Other notes

There are no additional notes.

## <a id="errors-enhancement"></a> ➡️ Improve the reported errors to the client application

### Problem

Right now the application is providing the raw error messges generated by any exception that happens in the code.

### Why it was done this way?

There was a lack of detailed definition for this behavior so it was decided to handle the errors and send that basic information meanwhile the definitive structure is set.

### Why this way is problematic?

The client application is not going to be able to idenfify what was the real cause of the error. Just to show the standar and generic result.

Additionally, this lack of information will be also present in the API logs so it will be more difficult to track the error origin.

### What the solution might be?

To create a custom set of errors specifically defined for the detected conflictive situations, based on the currently defined error classes in the framework.

To implement a custom error handle middleware in order to parse the generated information by the errors and provide a better response.

To include a custom error code, additional to the HTTP standar error. The idea of this independent code is to coordinate with the client application in order to provide a better look and feel.

### Why we aren't already doing the above?

There were no specifications about how to handle this kind of errors.

### Next steps

- To confirm the final behavior of error handling.
- To create the customized error classes.
- To implement the error handling middleware and connect it with the application.

### Other notes

There are no additional notes.

## <a id="implement-helmet"></a> ➡️ Improve the API security configuring sensitive headers

### Problem

Right now the responses provided by the application are the default defined by the framework. It means that there are some sensitive response headers whose are been sent to the client application.

### Why it was done this way?

This code is implemented following the version 4 of the framework and the middleware and sequences definions are different compared with the version 3.

To implement a success solution would had required additional researching tasks which were out of the defined development period.

### Why this way is problematic?

Any sensitive resonse header sent to client applications with any kind of control, could becomes on an attack vector and generate a security gap in the application.

### What the solution might be?

Implement already tested tools, like Helmet for instance, in order to configure and handle response headers.

### Why we aren't already doing the above?

To resolve this point requires additional researching time that was now avaible in the delivery period.

### Next steps

- To keep researching about how to implement Helmet in the application.
- To implement the needed sequences/middlewares in order to reach this goal.

### Other notes

There are no additional notes.

## <a id="implement-rate-limiter"></a> ➡️ Improve the API security implementing some kind of rate limiter

### Problem

Right now the responses to the whole requests it receives and it's not tracking who is sending them of from where they are comming from.

### Why it was done this way?

This code is implemented following the version 4 of the framework and the middleware and sequences definions are different compared with the version 3.

To implement a success solution would had required additional researching tasks which were out of the defined development period.

### Why this way is problematic?

A directed deny of service attach could be performed successfully aginst the API.

### What the solution might be?

Implement an already tested tool in order to track who and from where the requests have been sent.

Apply the needed rules in order to limit the response rate for those requests which overcome the defined thresholds.

### Why we aren't already doing the above?

To resolve this point requires additional researching time that was now avaible in the delivery period.

### Next steps

- To keep researching about how to implement this kind of solution.
- To implement the needed sequences/middlewares in order to reach this goal.

### Other notes

There are no additional notes.
